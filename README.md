
# Blob Eater Game (Agar.io)

This project is a simple 2D game where a player-controlled blob moves around a grid-like background, "eating" smaller blobs that randomly spawn within the game's space. As the player blob eats other blobs, it grows in size, making it easier to consume additional blobs.

## Features

- **Player Blob**: A central blob controlled by the mouse that grows as it eats smaller blobs.
- **Random Blobs**: Tiny dots that appear across the canvas, respawning at the edges when eaten.
- **Infinite Movement Simulation**: The screen moves relative to the player blob, creating an effect where the background and blobs stay stationary, simulating an expansive playing field.
- **Grid Background**: A stationary grid pattern provides orientation for player movement and improves the sense of depth and position.

## Game Mechanics

1. **Blob Movement**: The player blob follows the mouse cursor and moves within the coordinate space.
2. **Eating Mechanism**: If the player blob touches a smaller blob, it "eats" the smaller blob, which increases the player blob's size.
3. **Blob Respawn**: Once eaten, blobs respawn at a random location outside the player's immediate view, maintaining a steady population of blobs in the game.
4. **Zoom Effect**: As the player blob grows, the camera zooms out slightly to accommodate the larger size.

## Code Overview

### Global Variables

- `blob`: The player-controlled blob.
- `zoom`: Determines the zoom level for the canvas, adjusted as the player blob grows.
- `blobs`: An array holding all smaller, randomly positioned blobs on the canvas.

### Core Functions

#### `setup()`
- Initializes the canvas, player blob, and array of smaller blobs.
- Sets the player blob in the center and populates the canvas with 500 randomly positioned blobs.

#### `draw()`
- **Background and Grid**: Clears the canvas and draws a grid for orientation.
- **Camera Movement**: Centers the canvas on the player blob and adjusts zoom based on the player's size.
- **Player and Blob Updates**: Calls the `show` and `update` methods for the player blob. Loops through the `blobs` array to check if each blob is eaten by the player and, if so, respawns it outside the playerâ€™s view.

### Blob Class

The `Blob` class represents both the player and smaller blobs.

#### Properties
- `pos`: A vector representing the blob's position.
- `r`: Radius of the blob.

#### Methods

- `show()`: Draws the blob as a circle on the canvas.
- `update()`: Adjusts the player blob's position towards the mouse cursor.
- `eats(other)`: Checks if the player blob is close enough to "eat" another blob. If eaten, the player blob's size increases.

## Getting Started

### Prerequisites

- Install [p5.js](https://p5js.org/), a JavaScript library used for creating the canvas and rendering the game.

### Installation

1. Clone or download this repository.
2. Open the project folder and create an HTML file that includes a reference to the `p5.js` library and links the JavaScript file with the game code.

### Example `index.html` file:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blob Eater Game</title>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="game.js"></script> <!-- Make sure your file is named 'game.js' or update the path accordingly -->
    <script src="blob.js"></script> <!-- Make sure your file is named 'game.js' or update the path accordingly -->
</body>
</html>
```

3. Open `game.html` in a browser to play the game.

## Controls

- **Mouse**: The player blob follows the mouse cursor.

## Customization

You can customize the game by modifying variables:
- **Number of Blobs**: Change the number of blobs generated by adjusting the loop in `setup()`.
- **Blob Size**: Modify the radius in the `Blob` class constructor for different blob sizes.
- **Grid Size**: Adjust `gridSize` in `draw()` to change the spacing of the grid lines.

## License

This project is open-source and available for modification and personal use.

---

This README should provide a clear understanding of the project setup, mechanics, and customization options.
